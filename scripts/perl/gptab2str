#!/usr/bin/perl
#
# Programmer:    Craig Stuart Sapp <craig.stanford.edu>
# Creation Date: Sat Feb  2 16:10:47 PST 2019
# Last Modified: Sat Feb  2 18:50:26 PST 2019
# Filename:      gptab2str
# Syntax:        perl 5
# vim:           ts=3
#
# Description:   Guitar Pro ASCII tab to **str converter.  Use Humlib tool
#                str2mid to convert to MIDI.  Currently assumes 6 string
#                guitar, and a 4/4 meter, which is not always true.
#
#                Should also mostly work with Ultimate Guitar ASCII Tabs, which
#                have a more rigorous structure:
#                   https://www.ultimate-guitar.com/contribution/help/rubric
#

use strict;

my @files = @ARGV;
my @CONTENTS;

foreach my $file (@files) {
	convertFile($file);
}

exit(0);


##############################
##
## convertFile -- Convert a file from ASCII TAB format into **str data.
##   The first spine will be a **recip spine with the interpreted rhythm
##   of the music.  Currently the music is assumed to be in 4/4.
##

sub convertFile {
	my ($filename) = @_;
	open (FILE, $filename) or die "Cannot read file $filename";
	my @contents = <FILE>;
	@CONTENTS = @contents;
	close FILE;
	my @music = getMusic(@contents);
	my $header = getHeader(@contents);
	my $legend = getLegend(@contents);

	printMusic($header, $legend, @music);
}



##############################
##
## getHeader -- Return reference records that are extracted from the header
##     information in the file.  There can be two formats for the header:
##
##   Tempo = 96
##   [ARTIST]
## or
##    Title: [TITLE]
##    SubTitle: [SUBTITLE]
##    Artist: [PERFORMER]
##    Album: [ALBUM]
##    Words: [LYRICIST]
##    Music: [COMPSER]
##    Copyright: [COPYRIGHT]
##    Instructions: [INSTRUCTIONS]
##    Tabber: [ARRANGER]
##    Tempo = 74
##    [INSTRUMENT NAME]
##
##

sub getHeader {
	my @contents = @_;
	my @header;
	foreach my $line (@contents) {
		last if $line =~ /^\s*$/;
		chomp $line;
		push(@header, $line);
	}
	if (@header < 2) {
		return "";
	} elsif (@header == 2) {
		return shortHeader(@header);
	} else {
		return longHeader(@header);
	}
}



##############################
##
## longHeader -- More than two lines in this format:
##
##    Title: [TITLE]
##    SubTitle: [SUBTITLE]
##    Artist: [PERFORMER]
##    Album: [ALBUM]
##    Words: [LYRICIST]
##    Music: [COMPSER]
##    Copyright: [COPYRIGHT]
##    Instructions: [INSTRUCTIONS]
##    Tabber: [ARRANGER]
##    Tempo = 74
##    [INSTRUMENT NAME]
##
##

sub longHeader {
	my @header = @_;
	my $output = "";
	for (my $i=0; $i<@header; $i++) {
		my $line = $header[$i];
		if ($line =~ /^\s*Tempo\s*=\s*/) {
			my $newline = $header[$i+1];
			if ($newline !~ /^\s*$/) {
				$output .= "!!!instrument: $line\n";
			}
		}
		if ($line =~ /^\s*([^:]+)\s*:\s*(.*)\s*$/) {
			my $key = $1;
			my $value = $2;
			if ($key eq "Title") {
				$output .= "!!!OTL: $value\n";
			} elsif ($key eq "SubTitle") {
				$output .= "!!!subtitle: $value\n";
			} elsif ($key eq "Album") {
				$output .= "!!!OPR: $value\n";
			} elsif ($key eq "Copyright") {
				$output .= "!!!YOO: $value\n";

			} elsif ($key eq "Instructions") {
				if ($value !~ /tempo/i) {
					$output .= "!!!instructions: $value\n";
				}

			} elsif ($key eq "Tabber") {
				$value =~ s/\band\b/,/g;
				if ($value =~ /,/) {
					my @perfs = split(/\s*,\s*/, $value);
					for (my $i=0; $i<@perfs; $i++) {
						next if $perfs[$i] =~ /^\s*$/;
						$output .= "!!!LAR: $perfs[$i]\n";
					}
				} else {
					$output .= "!!!LAR: $value\n";
				}

			} elsif ($key eq "Words") {
				$value =~ s/\band\b/,/g;
				if ($value =~ /,/) {
					my @perfs = split(/\s*,\s*/, $value);
					for (my $i=0; $i<@perfs; $i++) {
						next if $perfs[$i] =~ /^\s*$/;
						$output .= "!!!LYR: $perfs[$i]\n";
					}
				} else {
					$output .= "!!!LYR: $value\n";
				}

			} elsif ($key eq "Music") {
				$value =~ s/\band\b/,/g;
				if ($value =~ /,/) {
					my @perfs = split(/\s*,\s*/, $value);
					for (my $i=0; $i<@perfs; $i++) {
						next if $perfs[$i] =~ /^\s*$/;
						$output .= "!!!COM: $perfs[$i]\n";
					}
				} else {
					$output .= "!!!COM: $value\n";
				}

			} elsif ($key eq "Artist") {
				$value =~ s/\band\b/,/g;
				if ($value =~ /,/) {
					my @perfs = split(/\s*,\s*/, $value);
					for (my $i=0; $i<@perfs; $i++) {
						next if $perfs[$i] =~ /^\s*$/;
						$output .= "!!!MPN: $perfs[$i]\n";
					}
				} else {
					$output .= "!!!MPN: $value\n";
				}
			} else {
				$output .= "!!!$key: $value\n";
			}

		}
	}

	return $output;
}



##############################
##
## shortHeader -- Two lines, first one is tempo second one
##     is artist (composer or performer).
##
## Format:
##   Tempo = 96
##   [ARTIST]
##

sub shortHeader {
	my @header = @_;
	my $output = "";
	if ($header[0] !~ /^\s*Tempo\s*=\s*/) {
		return "";
	}
	if ($header[1] !~ /^\s*$/) {
		$header[1] =~ s/\band\b/,/g;
		if ($header[1] =~ /,/) {
			my @perfs = split(/\s*,\s*/, $header[1]);
			for (my $i=0; $i<@perfs; $i++) {
				next if $perfs[$i] =~ /^\s*$/;
				$output .= "!!!MPN: $perfs[$i]\n";
			}
		} else {
			$output .= "!!!MPN: $header[1]\n";
		}
	}
	return $output;
}



##############################
##
## getLegend -- Return the legend information in the file which explains
##     the ornamentation symbols.
##
## Format:
##
## Legend
## L - tied note
## x - dead note
## h - hammer on/pull off
## b - bend
## s - slide
## ~ - vibrato
## t - trill
## M - palm mute
## . - staccato
## [then a blank line ends the legend]
## [or a line containing | might also work]
##

sub getLegend {
	my @contents = @_;
	my $startline = -1;
	for (my $i=0; $i<@contents; $i++) {
		if ($contents[$i] =~ /^\s*Legend\s*$/) {
			$startline = $i+1;
			last;
		}
	}
	return "" if $startline < 0;
	my $i = $startline;
	my $output = "";
	my $char;
	my $definition;
	for (my $i = $startline; $i<@contents; $i++) {
		my $line = $contents[$i];
		chomp $line;
		last if $line =~ /^\s*$/;
		if ($line =~ /^\s*([^\s]+)\s*-\s*(.*)\s*$/) {
			$char = $1;
			$definition = $2;
			$output .= "!!!RDF**str: $char = $definition\n";
		}
	}
	return $output;
}



##############################
##
## getMusic -- Return a continuous stream of each string.
##

sub getMusic {
	my @contents = @_;
	my @strings = ("", "", "", "", "", "");
	my $i = 0;
	my @systemStrings;
	my $lastchar = "";
	while ($i < @contents) {
		($i, $lastchar, @systemStrings) = getSystem($i, $lastchar, @contents);

		for (my $j=0; $j<@strings; $j++) {
			$strings[$j] .= $systemStrings[$j];
		}
	}

	return @strings;
}



##############################
##
## getSystem -- Find the next line (measure of music).  Assuming always 6 strings
##   (no ukulele or similar).  $lastchar is the last character on the previous line.
##   If it is not "|", that means that the measure is continuing from the previous system.
##   In that case, do not remove the first two characters on the new system line that follows.
##

sub getSystem {
	my ($startindex, $lastchar, @contents) = @_;
	my $newstart = -1;

	my @output = ("", "", "", "", "", "");

	# search for the next line that start a set of 6 strings.
	for (my $i = $startindex; $i<@contents; $i++) {
		if ($contents[$i] =~ /---/
				&& $contents[$i+1] =~ /---/
				&& $contents[$i+2] =~ /---/
				&& $contents[$i+3] =~ /---/
				&& $contents[$i+4] =~ /---/
				&& $contents[$i+5] =~ /---/) {
			$newstart = $i;
			last;
		}
	}
	if ($newstart < 0) {
		return ($#contents+1, @output);
	}
	# the line above the staff can have fade ins above it, so need to check here.
	for (my $i=0; $i<6; $i++) {
		my $line = @contents[$i+$newstart];
		chomp $line;
		$line =~ s/\|--/|/g;  # remove two dashes after barline
		$line =~ s/--\|/|/g;  # remove two dashes before barline
		$line =~ s/\s+//g;    # remove any spaces
		# Remove two lines at start of line only if the last system ends with a barline:
		$line =~ s/^--//g if $lastchar eq "|";
		$output[$i] = $line;
	}

	my $len = length($output[0]);
	for (my $j=1; $j<@output; $j++) {
		next if $len == length($output[$j]);
		my $ii = $newstart + 1;
		print "Error: unequal-equal length of string on staff near line $ii\n";
		print "Staff with problem:\n";
		for (my $k=0; $k<@output; $k++) {
			print"\t$output[$k]\n";
		}
		die;
	}

	$lastchar = substr($output[0], -1);

	return ($newstart + 6, $lastchar, @output);
}



##############################
##
## printMusic -- Print the reference records and prepare the main
##    contents of the music from prepared input strings and print as well.
##

sub printMusic {
	my ($header, $legend, @music) = @_;
	print $header;
	my $data = convertMusicToHumdrum(@music);
	print $data;
	print $legend;
}



##############################
##
## convertMusicToHumdrum -- Convert long input string for each insturment string
##    into a Humdrum spine.  A **recip spine for rhythm is added as the first spine.
##

sub convertMusicToHumdrum {
	my (@input) = @_;
	my @string1;
	my @string2;
	my @string3;
	my @string4;
	my @string5;
	my @string6;
	my @strings = (\@string1, \@string2, \@string3, \@string4, \@string5, \@string6);
	for (my $i=0; $i<@strings; $i++) {
		push(@{$strings[$i]}, "**str");
	}
	my $max = length($input[0]);
	my $char;
	my $ch;
	my $init = 0;
	for (my $i=0; $i<$max; $i++) {
		$char = substr($input[0], $i, 1);
		if ($char eq "|") {
			# barline (1 character wide)
			for (my $j=0; $j<@strings; $j++) {
				$ch = substr($input[$j], $i, 1);
				push(@{$strings[$j]}, $ch);
			}
			$init = 1;
		} elsif (!$init && $char =~ /[A-G]/) {
			# initial string tuning line
			for (my $j=0; $j<@strings; $j++) {
				$ch = substr($input[$j], $i, 1);
				$ch = "E3" if $j == 0 && $ch eq "E";
				$ch = "B2" if $j == 1 && $ch eq "B";
				$ch = "G2" if $j == 2 && $ch eq "G";
				$ch = "D2" if $j == 3 && $ch eq "D";
				$ch = "A1" if $j == 4 && $ch eq "A";
				$ch = "E1" if $j == 5 && $ch eq "E";
				push(@{$strings[$j]}, "*AT:$ch");
			}
			$init = 1;
		} else {
			# note (3 characters wide);
			for (my $j=0; $j<@strings; $j++) {
				$ch = substr($input[$j], $i, 3);
				if ($ch =~ /\|/) {
					print "Some strange error: found barline when not expecting it.:near index $i in $ch\n";
				}
				if ($ch eq "---") {
					$ch = ".";
				} else {
					$ch =~ s/-.*//;
				}
				push(@{$strings[$j]}, $ch);
			}
			$i += 2;
		}
	}
	for (my $i=0; $i<@strings; $i++) {
		push(@{$strings[$i]}, "*-");
	}

	my $barnum = 1;
	my $output = "";
	my $len = @{$strings[0]};
	my $tempout = "";
	my $barQ = 0;
	my $recip = ".";

	for (my $i=0; $i<$len; $i++) {
		$tempout = "";
		$barQ = 0;
		for (my $j=0; $j<@strings; $j++) {
			my $jj = @strings - $j - 1;
			my $token = ${$strings[$jj]}[$i];
			my $nexttoken = ${$strings[$jj]}[$i+1];
			my $lasttoken = ${$strings[$jj]}[$i-1];
			next if $token eq "|" && $nexttoken eq "|";
			if ($token eq "|" && $lasttoken eq "|") {
				$token = "==";
			} elsif ($token eq "|") {
				$token = "=$barnum";
				$barQ = 1;
				$recip = getRecipForNextMeasure($i+1, @strings);
			}
			if ($j == 0) {
				if ($token =~ /^=/) {
					$tempout .= $token;
				} elsif ($token =~ /^\*\*/) {
					$tempout .= "**recip";
				} elsif ($token =~ /^\*/) {
					$tempout .= "*";
				} else {
					$tempout .= $recip;
				}
			}
			$tempout .= "\t";
			$tempout .= $token;
		}
		$barnum++ if $barQ;
		if ($tempout !~ /^\s*$/) {
			$output .= "$tempout\n";
			if ($tempout =~ /^\*\*/) {
				# print assumed meter
				$output .= "*M4/4";
				for (my $j=0; $j<@strings; $j++) {
					$output .= "\t*M4/4";
				}
				$output .= "\n";
				my $tempo = getTempo(@CONTENTS);
				if ($tempo !~ /^\s*$/) {
					$output .= "$tempo";
					for (my $j=0; $j<@strings; $j++) {
						$output .= "\t$tempo";
					}
					$output .= "\n";
				}
			}
		}
	}

	return $output;
}



##############################
##
## getTempo -- Return the tempo as a **kern interpretation (if available).
##
## Format:
##    Tempo = 96
##

sub getTempo {
	my @contents = @_;
	foreach my $line (@contents) {
		if ($line =~ /^\s*Tempo\s*=\s*(\d+)/) {
			return "*MM$1";
		}
	}
	return "";
}



##############################
##
## getRecipForNextMeasure -- Calcualte the duration of each time unit
##    in the following measure.  Currently assumes always 4/4 meter.
##

sub getRecipForNextMeasure {
	my ($startindex, @strings) = @_;
	my $counter = 0;
	my $len = @{$strings[0]};
	for (my $i=$startindex; $i<$len; $i++) {
		my $token = ${$strings[0]}[$i];
		last if $token eq "|";
		$counter++;
	}
	return $counter;
}


